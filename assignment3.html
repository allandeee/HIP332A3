<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>assignment3.html</title>

</head>

<body>

<h1>Macquarie University, Department of Computing </h1>

<h2>COMP332 Programming Languages 2017 </h2>

<h2>Assignment 3 </h2>

<p>Due: 11.55pm Sunday 12 November 2017 (end of week 13)<br />
Worth: 15% of unit assessment</p>

<p>Marks breakdown:</p>

<ul>
<li>Code: 50% (of which tests are worth 10%)</li>
<li>Report: 50% (of which test description is worth 10%)</li>
</ul>

<p>Submit a notice of disruption via <a href="https://ask.mq.edu.au">Ask@MQ</a> if you are unable to submit on time for medical or other legitimate reasons.</p>

<p>Late penalty without proper justification: 20% of the full marks for the assessment per day or part thereof late.</p>

<h3>Overview </h3>

<p>This assignment asks you to extend the translator for the <a href="https://en.wikipedia.org/wiki/Hipster_(contemporary_subculture)">Hipster</a> cellular automaton language. Specifically you are asked to add translation code to handle <code>for</code> and <code>iterate...over</code> statements.</p>

<p>Building this implementation will give you insight into how compilers go about checking that the code you write satisfies the type rules of the programming language you are writing in. Overall these assignments are designed to reveal the way that domain programming language implementations work in general, as well as to provide you with specific experience of how language programs are written, how they are compiled, and how they are executed.</p>

<p>This kind of task often arises in programming situations other than language implementation. For example, many game engines provide specialised languages designed to make the process of specifying game mechanics easier, less error prone and more intuitive. The game engine software development kit (SDK) must provide tools to reliably read scripts written in such languages, understand their structure, and check the types of data they contain. The techniques used to construct those tools are no different to those used to build compilers for general purpose programming languages (like C and Java) or domain specific languages like Hipster.</p>

<p>The Hipster programming language, its syntax, and its name and type analysis rules are described in detail in the README file which you can find, in markdown and HTML formats, in the root directory of the assignment 3 skeleton. This assignment specification provides you with a full account of the target code that your completed compiler should generate for <code>for</code> and <code>iterate...over</code> statements.</p>

<h3>The CellSim cellular automaton simulator </h3>

<p>To run the code generated by the Hipster compiler we've provided you with a simple cellular automaton simulator, written in Java. You can clone this from the BitBucket repository at <a href="https://bitbucket.org/dominicverity/comp332-cellsim">https://bitbucket.org/dominicverity/comp332-cellsim</a>.</p>

<p>The translation phase of the Hipster compiler is setup to compile a Hipster program to the source code for a single Java class called <code>CellularAutomaton</code>. An object of that class contains all of the logic required to manage the state of a cellular automaton. It an inner class called <code>Cell</code> which implements the functionality of a single cell contained within a <code>CellularAutomaton</code> object.</p>

<p>To generate, compile and execute the code generated from a Hipster source file, just follow the following instructions:</p>

<ul>
<li><p>Open your terminal program and change directory to the root of your Hipster source directory.</p></li>
<li><p>Start the Scala simple build tool, by typing <code>sbt</code> at the command prompt.</p></li>
<li><p>Once you get to the <code>sbt</code> command prompt <code>hipster 0.1 2.12.3&gt;</code> you can now compile one of the Hipster source files in the <code>resources</code> directory by typing <code>run src/test/resources/&lt;name&gt;.hip</code>.</p></li>
<li><p>If this all works, then the compiler should print out the source text of a complete Java class called <code>CellularAutomaton</code>.</p></li>
<li><p>Copy that source text, including the package declaration at its very top, from the terminal and paste it into the <code>CellularAutomaton.java</code> file of the CellSim simulator. The text you've copied should completely replace all of the text of that file.</p></li>
<li><p>Now compile and execute the CellSim application using your favourite IDE or command line tool.</p></li>
</ul>

<p>You can also build a Hipster compiler stand-alone executable by typing</p>

<pre><code>    sbt assemble 
</code></pre>

<p>at your command prompt (in the hipster project root directopry). Once you've done that, you can execute the Hipster compiler from the MacOSX or Linux command line using the following command</p>

<pre><code>    ./hipster src/test/resources/&lt;file&gt;.hip
</code></pre>

<p>which executes a shell script to startup the compiler. I don't have access to a Windows box, so I haven't been able to construct a <code>.bat</code> file for you. But assuming that Java is correctly installed you should be able to run the Hipster compiler using the command:</p>

<pre><code>    java -jar target/scala-2.12/Hipster-assembly-0.1.jar src/test/resources/&lt;file&gt;.hip
</code></pre>

<p>Finally, if you are using an IDE like IntelliJ/Idea to develop your Scala code, you should be able to setup a run profile to execute the Hipster compiler on a file. On executing that profile, the Java text of the compiled code should appear in the IDE's console, and you can copy and paste it into place from there.</p>

<h3>What you have to do </h3>

<p>Before you start this assignment, it is strongly recommended that you should take an hour or two to familiarise yourself with the translator code provided in the <code>Translator.scala</code> module. This largely follows the principles introduced in the lectures and in the Expression language compiler.</p>

<p>You are not expected to understand all of this translation code in detail to complete this assignment, it is a little complicated in places. To help you, we've documented the translation functions you will need to call in your own code below. You can complete the implementation of the Hipster translator in this assignment using only the translation functions documented below and around 30-40 lines of carefully chosen Scala code. Just replace the existing code at the <code>FIXME</code> comments with your own translation code.</p>

<p>Your task is to add code to the <code>Translator.scala</code> module to implement translations for <code>for</code> and <code>iterate...over</code> statements, as described in the next two sections:</p>

<h3>Translating <code>iterate...over</code> statements </h3>

<p>An <code>iterate...over</code> statement scans through a fixed and <em>small</em> set of neighbour symbols, setting its control variable to each one in turn and then executing the code in its body. We choose not to implement this as a loop, because loops of only a few iterations are usually more efficiently translated by <em>unrolling</em> them into a sequence of copies of their bodies. This save us the run-time overhead of initialising and executing a loop, not to mention that it greatly simplifies the translation of these constructs.</p>

<p>So, for example, suppose our automaton used a Von-Neumann neighbourhood</p>

<pre><code>neighbourhood 
    N = [0,1], S = [0,-1], W = [-1,0], E = [1,0];
</code></pre>

<p>then the <code>iterate...over</code> statement</p>

<pre><code>iterate cell over others
    grad = grad + (cell:conc - conc);
</code></pre>

<p>might be translated into the following Java code:</p>

<pre><code>01  {
02      Cell cell$14;
03      cell$14 = N$8;
04      grad$13 = grad$13 + (cell$14.conc$12 - conc$12);
05      cell$14 = S$9;
06      grad$13 = grad$13 + (cell$14.conc$12 - conc$12);
07      cell$14 = W$10;
08      grad$13 = grad$13 + (cell$14.conc$12 - conc$12);
09      cell$14 = E$11;
10      grad$13 = grad$13 + (cell$14.conc$12 - conc$12);
11  }
</code></pre>

<p>Here we've added the line numbers to allow us to refer to specific lines in the description that follows.</p>

<p>Important points to note in this translated code are:</p>

<ul>
<li><p>The control variable <code>cell</code> is translated into a Java variable <code>cell$14</code> of type <code>Cell</code>, which is declared on line <code>1</code>. In general, you can think of a variable or constant of type <code>neighbour</code> in Hipster as corresponding to a reference to a <code>Cell</code> object in Java.</p></li>
<li><p>The code on lines <code>4</code>, <code>6</code>, <code>8</code> and <code>10</code> are simply copies of the code obtained by translating the Hipster assignment statement <code>grad = grad + (cell:conc - conc)</code> that comprises the body of the <code>iterate...over</code> statement. There is one copy of that translated code here for each entry in the set <code>others</code>, that is the set of neighbours <code>[N, S, W, E]</code>.</p></li>
<li><p>The code on lines <code>3</code>, <code>5</code>, <code>7</code> and <code>9</code> sets the variable <code>cell$14</code> to refer to each of the cell objects corresponding to the neighbours <code>N</code>, <code>S</code>, <code>W</code> and <code>E</code> in turn.</p></li>
<li><p>All of this code is enclosed in a block, starting at line <code>1</code> and ending at line <code>11</code>. This constrains the scope of the variable <code>cell$14</code>, whose definition should not <em>leak</em> outside of the boundaries of the code translated from the <code>iterate...over</code> statement. This implements the scoping rule for the corresponding control variable <code>cell</code> in the Hipster source code.</p></li>
</ul>

<p>We might describe this translation in semi-formal notation by saying that a Hipster statement</p>

<pre><code>iterate &lt;id&gt; over [&lt;N1&gt;, &lt;N2&gt;, ..., &lt;Nr&gt;] &lt;body&gt;
</code></pre>

<p>translates to the Java code:</p>

<pre><code>{
    Cell &lt;&lt;id&gt;&gt;;
    &lt;&lt;id&gt;&gt; = &lt;&lt;N1&gt;&gt;;
    &lt;&lt;body&gt;&gt;
    &lt;&lt;id&gt;&gt; = &lt;&lt;N2&gt;&gt;;
    &lt;&lt;body&gt;&gt;
      .
      .
      .
    &lt;&lt;id&gt;&gt; = &lt;&lt;Nr&gt;&gt;;
    &lt;&lt;body&gt;&gt;
}
</code></pre>

<p>Here the if a word <code>&lt;fragment&gt;</code> represents some fragment of Hipster code then we use the notation <code>&lt;&lt;fragment&gt;&gt;</code> to denote its translation into Java. So <code>&lt;&lt;id&gt;&gt;</code> is the Java translation of the Hipster identifier <code>&lt;id&gt;</code>, the control variable of the source <code>iterate...over</code> construct, and <code>&lt;&lt;body&gt;&gt;</code> is the Java translation of the Hipster statement <code>&lt;body&gt;</code>, which comprises its body.</p>

<h3>A note on translating identifier names </h3>

<p>You will have noted that all of the variable names in the translated Java code above have been transformed from the original name in the Hipster source code by appending a <code>$</code> followed by a unique integer. For example, the Hipster identifier <code>cell</code> was translated to the <em>mangled</em> Java identifier <code>cell$14</code> and the neighbour symbols were translated to mangled identifiers <code>N$8</code>, <code>S$9</code>, <code>W$10</code> and <code>E$11</code>.</p>

<p>This translation, or <em>mangling</em>, of names serves two purposes. Firstly, it distinguish names introduced by the compiler from the names used in the CellSim simulator source code, since none of the latter names contain a <code>$</code> symbol.</p>

<p>Secondly, and more importantly, it solves a problem arising from a difference in the treatment of variable <em>shadowing</em> in Hipster and Java. To understand this difference, consider the following code:</p>

<pre><code>{
    int var;
    var = 10;
    // point A
    {
        int var;
        var = 20;
        // point B
    }
    // point C
}
</code></pre>

<p>As a fragment of code in Hipster this is perfectly legal, the variable <code>var</code> can be re-declared in the inner block, where it shadows the variable with the same name in to outer block. So if we access <code>var</code> at locations <code>A</code> and <code>C</code>, either side of the inner block, then it refers to the same storage location containing the value <code>10</code> at those points. On the other hand, if we access it at point <code>B</code> it refers to a different memory location containing the value <code>20</code>.</p>

<p>On the other hand, in Java this code is disallowed, its semantics regards the shadowing of variables by variables of the same name in inner blocks as strictly illegal. To make this into legal code in Java we have to use different variable names in the inner and outer blocks, as in the following for example:</p>

<pre><code>{
    int var$1;
    var$1 = 10;
    // ...
    {
        int var$2;
        var$2 = 20;
        // ...
    }
    // ...
}
</code></pre>

<p>So to translate Hipster into Java, we must first rename the identifiers in the Hipster source code in a way which ensures that shadowing variables are translated to variables in the Java target code that have names distinct from the variables they shadow. We do this by uniquely numbering each defining instance of all variables in the Hipster source and appending a <code>$</code> symbol followed by that number to each Java identifier obtained by translating any defining or applied instance of that variable. This is done using an environment base attribution process not unlike that deployed in the name analyser. This name mangling code can be found in the <code>TranslationAttributes.scala</code> module, and its use is described a little later on.</p>

<h3>Translating <code>for</code> statements </h3>

<p>The Hipster compiler translates <code>for</code> statements into <code>while</code> loops. For example, it translates the following loop</p>

<pre><code>for count = 1 to 6
    drop_blob(rnd(width), rnd(height), 10);
</code></pre>

<p>into the Java fragment:</p>

<pre><code>01  {
02      int count$47 = 1;
03      int _end$49 = 6;
04      int _step$50 = 1;
05      boolean _dirn$48 = _step$50 &gt;= 0;
06      if (_step$50 != 0)
07          while (_dirn$48 &amp;&amp; _end$49 &gt;= count$47 || 
08                  (!_dirn$48 &amp;&amp; _end$49 &lt;= count$47)) {
09              drop_blob$31(_rnd(width$5), _rnd(height$6), 10);
10              count$47 = count$47 + _step$50;
11          }
12  }
</code></pre>

<p>The key points in this translation are:</p>

<ul>
<li><p>The whole sequence of translated code is contained in a block, starting at line <code>1</code> and ending at line <code>12</code>. This ensures that the control variable and any other variables declared to orchestrate the activities of our loop cannot leak into the outer scope.</p></li>
<li><p>On line <code>2</code> we evaluate the translated &quot;start&quot; expression and assign the resulting value to the newly declared variable <code>count$47</code>, that being the translation of the control variable of our <code>for</code> loop.</p></li>
<li><p>In lines <code>3</code> and <code>4</code> we evaluate the translations of the &quot;end&quot; and &quot;step&quot; expressions, and assign the resulting values to the newly declared internal variables <code>_end$49</code> and <code>_step$50</code> respectively. Notice here that if the &quot;step&quot; expression is missing, as it is in the example above, then the default is to set the <code>_step$50</code> variable to the constant expression <code>1</code>.</p></li>
<li><p>In line <code>5</code> we set an internal <code>boolean</code> variable <code>_dirn$48</code> to <code>true</code> if the specified step size, stored in <code>_step$50</code> is positive and to false if it is strictly negative. This variable will be used in the termination condition for the loop later on, because that condition will vary depending on whether our loop is counting upwards or downwards.</p></li>
<li><p>In line <code>6</code> we check to see if the step size is non-zero, and only execute the loop code if it is. If step were equal to zero then each iteration of the loop would not alter the control variable and the loop would never terminate. This would be a bad thing for the CellSim simulator, because it might cause an initialiser to go into an infinite loop and lock up its GUI.</p></li>
<li><p>In line <code>7</code> we start the loop itself, and we use a Java `while** loop for this purpose. The termination condition has two arms in which:</p>

<ul>
<li><p> the loop is counting upwards (<code>_dirn$48_ = true</code>) in which case we continue looping while the end value is <em>greater than or equal to</em> the value in the control variable (<code>_end$49 &gt;= count$47</code>), or</p></li>
<li><p> the loop is counting downwards (<code>_dirn$48_ = false</code>) in which case we continue looping while the end value is <em>less than or equal to</em> the value in the control variable (<code>_end$49 &gt;= count$47</code>).</p></li>
</ul>

<p>This condition ensures that the loop will eventually terminate.</p></li>
<li><p>The code in line <code>8</code> is constructed by translating the statement that comprises the body of the loop.</p></li>
<li><p>Finally. the code in line <code>9</code> advances the value in the control variable <code>_count$47</code> by adding the step value stored in <code>_step$50</code>.</p></li>
</ul>

<p>We can summarise this translation in our semi-formal notation, by saying that a Hipster statement</p>

<pre><code>for &lt;id&gt; = &lt;start&gt; to &lt;end&gt; step &lt;step&gt; &lt;stmt&gt;
</code></pre>

<p>translates into the following Java code:</p>

<pre><code>{
    int &lt;&lt;id&gt;&gt; = &lt;&lt;start&gt;&gt;;
    int _end$XX = &lt;&lt;end&gt;&gt;;
    int _step$YY = &lt;&lt;step&gt;&gt;;
    boolean _dirn$ZZ = _step$YY &gt;= 0;
        
    if (_step$YY != 0)
        while ((_dirn$ZZ &amp;&amp; (_end$XX &gt;= &lt;&lt;id&gt;&gt;)) ||
                (!_dirn@ZZ &amp;&amp; (_end$XX &lt;= &lt;&lt;id&gt;&gt;))) {
            &lt;&lt;stmt&gt;&gt;
            &lt;&lt;id&gt;&gt; = &lt;&lt;id&gt;&gt; + _step$YY;
        }
}
</code></pre>

<h3>Key technical points - Java trees and useful translation functions </h3>

<p>Translated Java code is represented in the Hipster compiler using trees not unlike those of the Hipster source code. The definition of the case classes that comprise these trees can be found in the <code>MiniJavaTree.scala</code> module.</p>

<p>To keep the names of Java and Hipster tree nodes distinct, we use the following <em>qualified</em> import to import the <code>MiniJavaTree.scala</code> module into the <code>Traslator.scala</code> module:</p>

<pre><code>import compiler.{MiniJavaTree =&gt; J}
</code></pre>

<p>So to reference a Java tree node class you have to add a prefix <code>J.</code> to the symbol defined in the <code>MiniJavaTree.scala</code> module.</p>

<p>Ultimately, once translation is complete, the compiler pretty prints the constructed Java tree as recognisable Java code. The code to do that pretty printing may be found in the <code>PrettyPrinter.scala</code> module.</p>

<p>As an example of translating a Hipster statement into a Java one, here is the case clause that translates <code>if</code> expressions:</p>

<pre><code>case IfStmt(exp, thn, els) =&gt;
    // Translate directly into corresponding Java if statement.
    J.If(translateExpr(exp), translateStmt(thn),
        els.map(translateStmt).getOrElse(J.Empty()))
</code></pre>

<p>Notice that the constructors <code>J.If</code> and <code>J.Empty()</code> both have the <code>J.</code> prefix, because they construct Java tree nodes. This translation proceeds by:</p>

<ul>
<li><p>Calling the expression translation function to form the translated control expression <code>translateExpr(exp)</code>.</p></li>
<li><p>Calling the statement translation function to form the translation of the &quot;then&quot; block statement <code>translateStmt(thn)</code>.</p></li>
<li><p>Calling the statement translation function to form the translation of the &quot;else&quot; block statement, or to construct the empty <code>J.Empty()</code> statement if there is no else block.</p></li>
<li><p>Finally these components are put together, becoming the parameters to the construction of a Java if node by a call to the <code>J.If</code> constructor.</p></li>
</ul>

<p>Notice there that the <code>els</code> field in a <code>If</code> node has type <code>Option[Statement]</code>, so its value is either <code>Some(stmt)</code> or <code>None</code>. The code <code>els.map(translateStmt)</code> applies <code>translateStmt</code> to <code>stmt</code> in the first case to return <code>Some(translateStmt(stmt))</code> and in the second case it simply returns <code>None</code>. In other words, it is equivalent to the pattern matching code:</p>

<pre><code>els match {
    case Some(stmt) =&gt; Some(translateStmy(stmt))
    case None =&gt; None
}
</code></pre>

<p>Then the call to the method <code>getOrElse(J.Empty())</code> either returns the value <code>jstmt</code> if <code>els.map(translateStmt)</code> is the value <code>Some(jstmt)</code> and it returns the default <code>J.Empty()</code> if it is <code>None</code>. So we could have also written the whole of the &quot;one-liner&quot; <code>els.map(translateStmt).getOrElse(J.Empty())</code> as</p>

<pre><code>els match {
    case Some(stmt) =&gt; translateStmt(stmt)
    case None =&gt; J.Empty()
}
</code></pre>

<p>In your translation code you will need to make use of the following translation functions defined in the modules <code>Translator.scala</code> and <code>TranslationAttributes.scala</code>:</p>

<pre><code>def translateExpr(exp : Expression) : J.Expression
</code></pre>

<p>This translates the Hipster expression tree passed as its parameter into a corresponding Java expression tree.</p>

<pre><code>def translateStmt(stmt : Statement) : J.Statement
</code></pre>

<p>This translates the Hipster statement tree passed as its parameter into a corresponding Java statement tree. The definition of this function is incomplete in the framework bundle, its translations of <code>ForStmt</code> and <code>IterateOverStmt</code> nodes simply return the empty Java statement <code>J.Empty()</code>. This is the only function you should alter in order to complete the Hipster translator.</p>

<pre><code>def translateNeighbourSet(s : NeighbourSet) : Vector[J.LValue]
</code></pre>

<p>This translates a Hipster neighbour set expression occurring in an <code>iterate...over</code> statement into a corresponding list of Java expressions. These are the expressions that should each be assigned, one after the other, to the translated control variable of the <code>iterate...over</code> loop as discussed in the translation above.</p>

<pre><code>def getTargetName(n : IdnNode) : String
</code></pre>

<p>This function does the heavy lifting of translating the identifiers in the Hipster source tree into corresponding mangled and numbered identifiers in the Java tree. To obtain the Java translated name corresponding to an identifier in the Hipster source tree simply apply this function the <code>IdnDef</code> or <code>IdnUse</code> node of that identifier. You don't really need to know how this translation works, although for interest sake you might want to consult the <code>TranslationAttributes.scala</code> module to find out.</p>

<pre><code>def getTargetName(n : HipsterNode, s : String) : String
</code></pre>

<p>This function allows you to obtain unique names for the various internal variables used in the translation of the <code>for</code> statement above. So, in particular, to obtain correctly numbered versions of the variables <code>_end$XX</code>, <code>_step$YY</code> and <code>_dirn$ZZ</code> mentioned in the <code>for</code> translation above you can make the following calls:</p>

<pre><code>    getTargetName(b, &quot;_end&quot;)
    getTargetName(b, &quot;_step&quot;)
    getTargetName(b, &quot;_dirn&quot;)
</code></pre>

<p>Here the variable <code>b</code> should be bound to the body statement tree of the Hipster <code>If</code> node that we are translating. This variable is bound correctly for you in the case clause:</p>

<pre><code>    case ForStmt(i, s, e, st, b) =&gt; ....
</code></pre>

<p>The names <code>_end</code>, <code>_step</code> and <code>_dirn</code> are &quot;hard-coded&quot; into the <code>getTargetName</code> code, so you must use these in your translation.</p>

<h3>What you must hand in and how </h3>

<p>A zip file containing all of the code for your project and a type-written report.</p>

<p>Submit every source and build file that is needed to build your program from source, including files in the skeleton that you have not changed. Do not add any new files or include multiple versions of your files. Do not include any libraries or generated files (run the sbt <code>clean</code> command before you zip your project). We will compile all of the files that you submit using sbt, so you should avoid any other build mechanisms.</p>

<p>Your submission should include all of the tests that you have used to make sure that your program is working correctly. Note that just testing one or two simple cases is not enough for many marks. You should test as comprehensively as you can.</p>

<p>Your report should describe how you have achieved the goals of the assignment. Do not neglect the report since it is worth 50% of the marks for the assignment.</p>

<p>Your report should contain the following sections:</p>

<ul>
<li>A title page or heading that gives the assignment details, your name and student number.</li>
<li>A brief introduction that summarises the aim of the assignment and the structure of the rest of the report.</li>
<li>A description of the design and implementation work that you have done to achieve the goals of the assignment. Listing some code fragments may be useful to illustrate your description, but don't give a long listing. Leaving out obvious stuff is OK, as long as what you have done is clear. A good rule of thumb is to include enough detail to allow a fellow student to understand it if they are at the stage you were at when you started work on the assignment.</li>
<li>A description of the testing that you carried out. You should demonstrate that you have used a properly representative set of test cases to be confident that you have covered all the bases. Include details of the tests that you used and the rationale behind why they were chosen. Do not just print the tests out without explanation.</li>
</ul>

<p>Submit your code and report electronically as a single zip file called <code>ass3.zip</code> using the appropriate submission link on the COMP332 iLearn website by the due date and time. Your report should be in PDF format.</p>

<p>DO NOT SUBMIT YOUR ASSIGNMENT OR DOCUMENTATION IN ANY OTHER FORMAT THAN ZIP and PDF, RESPECTIVELY. Use of any other format slows down the marking and may result in a mark deduction.</p>

<h3>Marking </h3>

<p>The assignment will be assessed according to the assessment standards for the unit learning outcomes.</p>

<p>Marks will be allocated equally to the code and to the report. Your code will be assessed for correctness and quality with respect to the assignment description. Marking of the report will assess the clarity and accuracy of your description and the adequacy of your testing. 20% of the marks for the assignment will be allocated to testing.</p>

<hr />

<p><a href="http://orcid.org/0000-0002-4137-6982">Dominic Verity</a><br />
Last modified: 29 October 2017<br />
<a href="http://www.mq.edu.au/legalstuff.html">Copyright (c) 2017 by Dominic Verity. All rights reserved.</a></p>

</body>
</html>
