/**
  * Hipster cellular automaton language.
  * Type analysis, tests of inferred type attribution.
  *
  * Â© 2017, Dominic Verity, Macquarie University, All rights reserved.
  * 
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  */

package compiler

import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner

/**
  * Tests of inferred type attribution.
  */
@RunWith(classOf[JUnitRunner])
class InferredTypeTests extends SemanticTests {

  // Check the inferred types of manifest constants.

  test ("verify inferred type of the boolean constant 'true'") {
    val messages =
      semanticTestInline ("""
                |dimension (true,100);
                |neighbourhood N = [0,1];
                |state {}
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertTypeErrorWithInferredType(messages, 0, 2, 12, "boolean")
  }

  test ("verify inferred type of the boolean constant 'false'") {
    val messages =
      semanticTestInline ("""
                |dimension (false,100);
                |neighbourhood N = [0,1];
                |state {}
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertTypeErrorWithInferredType(messages, 0, 2, 12, "boolean")
  }

  test ("verify inferred type of a float constant") {
    val messages =
      semanticTestInline ("""
                |dimension (12.23,100);
                |neighbourhood N = [0,1];
                |state {}
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertTypeErrorWithInferredType(messages, 0, 2, 12, "float")
  }

  test ("verify inferred type of the neighbour constant 'me'") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean c = me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertTypeErrorWithInferredType(messages, 0, 5, 13, "neighbour")
  }

  test ("verify inferred type of an integer constant") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean c = 13;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertTypeErrorWithInferredType(messages, 0, 5, 13, "int")
  }

  // Tests of the generation and propagation of the unknown type up
  // an expression tree.

  // Because unknown types stifle type errors further up an expression
  // tree, we can't verify the presence of unknown by checking for it
  // in the text of a type error.

  // So we test these by using an erroneous expression as the initialiser
  // in a constant declaration whose type disagrees with that of the
  // top level operator in that expression. Then the absence of a type
  // error for that declaration enables us to infer that the unknown type
  // has propagated to the top of the expression tree.

  // Unknown type generated by type errors in left hand operand of
  // arithmetic op.

  test ("verify generation of unknown type by type error in left hand operand of + operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true + 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 13,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify generation of unknown type by type error in left hand operand of - operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true - 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 13,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify generation of unknown type by type error in left hand operand of * operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true * 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 13,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify generation of unknown type by type error in left hand operand of / operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true / 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 13,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

    test ("verify generation of unknown type by type error in left hand operand of % operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true % 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 13,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  // Unknown type generated by type errors in right hand operand of
  // arithmetic op.

  test ("verify generation of unknown type by type error in right hand operand of + operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10 + true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 18,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify generation of unknown type by type error in right hand operand of - operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10 - true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 18,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify generation of unknown type by type error in right hand operand of * operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10 * N;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 18,
      "type error, expecting 'int' or 'float' found 'neighbour'")
  }

  test ("verify generation of unknown type by type error in right hand operand of / operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10 / me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 18,
      "type error, expecting 'int' or 'float' found 'neighbour'")
  }

    test ("verify generation of unknown type by type error in right hand operand of % operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10.1 % false;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 20,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  // Unknown type generated by type errors in operand of unary
  // arithmetic op.

  test ("verify generation of unknown type by type error in right hand operand of unary - operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = -true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 14,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  // Unknown type generated by type errors in left hand operand of
  // boolean op.

  test ("verify generation of unknown type by type error in left hand operand of || operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = 10 || true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify generation of unknown type by type error in left hand operand of && operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = me && true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'boolean' found 'neighbour'")
  }

  // Unknown type generated by type errors in right hand operand of
  // boolean op.

  test ("verify generation of unknown type by type error in right hand operand of || operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true || 10.1;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 17,
      "type error, expecting 'boolean' found 'float'")
  }

  test ("verify generation of unknown type by type error in right hand operand of && operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true && me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 17,
      "type error, expecting 'boolean' found 'neighbour'")
  }

  // Unknown type generated by type errors in operand of unary
  // boolean op.

  test ("verify generation of unknown type by type error in right hand operand of unary ! operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = !10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'boolean' found 'int'")
  }

  // Unknown type generated by type errors in right operand of equals

  test ("verify generation of unknown type by type error in == operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true == me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 17,
      "type error, expecting 'boolean' found 'neighbour'")
  }

  // Unknown type generated by type errors in operands of relational
  // operators.

  test ("verify generation of unknown type by type error in left hand operand of < operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = me < 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'int' or 'float' or 'boolean' found 'neighbour'")
  }

  test ("verify generation of unknown type by type error in right hand operand of < operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true < 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 16,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify generation of unknown type by type error in left hand operand of > operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = me > 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'int' or 'float' or 'boolean' found 'neighbour'")
  }

  test ("verify generation of unknown type by type error in right hand operand of > operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true > 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 16,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify generation of unknown type by type error in left hand operand of <= operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = me <= 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'int' or 'float' or 'boolean' found 'neighbour'")
  }

  test ("verify generation of unknown type by type error in right hand operand of <= operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true <= 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 17,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify generation of unknown type by type error in left hand operand of >= operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = me >= 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 9,
      "type error, expecting 'int' or 'float' or 'boolean' found 'neighbour'")
  }

  test ("verify generation of unknown type by type error in right hand operand of >= operator") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = true >= 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 17,
      "type error, expecting 'boolean' found 'int'")
  }

  // Tests to make sure that unknown types propagating to the left
  // hand operand of a relation don't also trigger a type error 
  // arising from the right hand operand.

  test ("verify that unknown type of left hand operand in == doesn't trigger type error on right hand side") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = -true == 10;
                |int b = -true == 10.1;
                |int c = -true == false;
                |int d = -true == me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 4, "expecting four errors")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 6, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 2, 7, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 3, 8, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify that unknown type of left hand operand in < doesn't trigger type error on right hand side") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = -true < 10;
                |int b = -true < 10.1;
                |int c = -true < false;
                |int d = -true < me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 4, "expecting four errors")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 6, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 2, 7, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 3, 8, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify that unknown type of left hand operand in > doesn't trigger type error on right hand side") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = -true > 10;
                |int b = -true > 10.1;
                |int c = -true > false;
                |int d = -true > me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 4, "expecting four errors")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 6, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 2, 7, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 3, 8, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

    test ("verify that unknown type of left hand operand in <= doesn't trigger type error on right hand side") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = -true <= 10;
                |int b = -true <= 10.1;
                |int c = -true <= false;
                |int d = -true <= me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 4, "expecting four errors")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 6, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 2, 7, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 3, 8, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify that unknown type of left hand operand in >= doesn't trigger type error on right hand side") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int a = -true >= 10;
                |int b = -true >= 10.1;
                |int c = -true >= false;
                |int d = -true >= me;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 4, "expecting four errors")
    assertMessage(messages, 0, 5, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 6, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 2, 7, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 3, 8, 10,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  // Tests of propagation of unknown type in more complex expressions

  test ("verify propagation of unknown type in arithmetic expression (one)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = -true + 10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 14,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify propagation of unknown type in arithmetic expression (two)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 10 % -true;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 19,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify propagation of unknown type in arithmetic expression (three)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = 45 / (-true + 10) * (10 - 25.1);
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 20,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

  test ("verify propagation of unknown type in arithmetic expression (four)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = -(((21.2 + -true / 10) * (10 - 25.1)) % 45);
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 25,
      "type error, expecting 'int' or 'float' found 'boolean'")
  }

    test ("verify propagation of two unknown types in arithmetic expression") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = -(((21.2 + -true / 10) * (10 - me)) % 45);
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 2, "expecting one error")
    assertMessage(messages, 0, 5, 25,
      "type error, expecting 'int' or 'float' found 'boolean'")
    assertMessage(messages, 1, 5, 44,
      "type error, expecting 'int' or 'float' found 'neighbour'")
  }

  test ("verify propagation of unknown type in boolean expression (one)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = true && !10;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 22,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify propagation of unknown type in boolean expression (two)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = !10 || false;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 14,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify propagation of unknown type in boolean expression (three)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = !(true && (!10 || false && true));
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 1, "expecting one error")
    assertMessage(messages, 0, 5, 25,
      "type error, expecting 'boolean' found 'int'")
  }

  test ("verify propagation of two unknown types in boolean expression") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean a = !(true && ((!10 || false) && true) || (me && true));
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 2, "expecting two errors")
    assertMessage(messages, 0, 5, 26,
      "type error, expecting 'boolean' found 'int'")
    assertMessage(messages, 1, 5, 52,
      "type error, expecting 'boolean' found 'neighbour'")
  }

  // Finally a collection of tests to check the inferred type of
  // some increasingly complex, but type correct, expressions.

  // At this stage we can afford for these tests to be a little
  // less fine grained

  test ("check inferred type of some arithmetic expressions (one)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int n = 10;
                |float m = 1.1;
                |boolean a = 10 + n;
                |boolean b = 10 % m;
                |boolean c = m * n;
                |boolean d = m + m;
                |boolean e = -n;
                |boolean f = -m;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 6, "expecting six errors")
    assertTypeErrorWithInferredType(messages, 0, 7, 13, "int")
    assertTypeErrorWithInferredType(messages, 1, 8, 13, "float")
    assertTypeErrorWithInferredType(messages, 2, 9, 13, "float")
    assertTypeErrorWithInferredType(messages, 3, 10, 13, "float")
    assertTypeErrorWithInferredType(messages, 4, 11, 13, "int")
    assertTypeErrorWithInferredType(messages, 5, 12, 13, "float")
  }

  test ("check inferred type of some arithmetic expressions (two)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int n = 10;
                |float m = 1.1;
                |boolean a = n * 10 + n;
                |boolean b = 12 - 10 % m;
                |boolean c = m / n / 10 ;
                |boolean d = m + m * m;
                |boolean e = -m * n;
                |boolean f = 12 * -n;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 6, "expecting six errors")
    assertTypeErrorWithInferredType(messages, 0, 7, 13, "int")
    assertTypeErrorWithInferredType(messages, 1, 8, 13, "float")
    assertTypeErrorWithInferredType(messages, 2, 9, 13, "float")
    assertTypeErrorWithInferredType(messages, 3, 10, 13, "float")
    assertTypeErrorWithInferredType(messages, 4, 11, 13, "float")
    assertTypeErrorWithInferredType(messages, 5, 12, 13, "int")
  }

  test ("check inferred type of some arithmetic expressions (three)") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |int n = 10;
                |float m = 1.1;
                |boolean a = n * ((10 + n) / 2);
                |boolean b = 1.1 * 12 - 10 % m;
                |boolean c = -(m / n - n / 10) * (5 + n * 8);
                |boolean d = ((m + 0 - 5.5) * m) % 5 + 1.1 / (n + n * 2);
                |boolean e = -(-m * n) * (n - 1) * (n - 2) * 3 * 2 * 1;
                |boolean f = 1 + 2 * 3 / 4 % 5 + n + n;
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 6, "expecting six errors")
    assertTypeErrorWithInferredType(messages, 0, 7, 13, "int")
    assertTypeErrorWithInferredType(messages, 1, 8, 13, "float")
    assertTypeErrorWithInferredType(messages, 2, 9, 13, "float")
    assertTypeErrorWithInferredType(messages, 3, 10, 13, "float")
    assertTypeErrorWithInferredType(messages, 4, 11, 13, "float")
    assertTypeErrorWithInferredType(messages, 5, 12, 13, "int")
  }

  test ("check inferred type of some boolean expressions of varied complexity") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean t = true;
                |boolean s = false;
                |int a = true && t;
                |int b = t || (s && t);
                |int c = !(t && s) || true;
                |int d = !t && (true || !s) ;
                |int e = (t && (s || !(true && t))) && !false;
                |int f = !(t && !(!(s || false) && t)) && !(true && false);
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 6, "expecting six errors")
    assertTypeErrorWithInferredType(messages, 0, 7, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 1, 8, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 2, 9, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 3, 10, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 4, 11, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 5, 12, 9, "boolean")
  }

  test ("check inferred type of some relational expressions of varied complexity") {
    val messages =
      semanticTestInline ("""
                |dimension (100,100);
                |neighbourhood N = [0,1];
                |state {}
                |boolean t = true;
                |boolean s = false;
                |int n = 10;
                |float m = 1.1;
                |int a = 4 <= m;
                |int b = (m < n) == true;
                |int c = !(m == n) && (false > true) || (1 <= 2);
                |int d = !t && (true || !s) ;
                |int e = (t && (s || !(true && t))) && !false;
                |int f = !(t && !(!(s || false) && t)) && !(true && false);
                |updater {}
                |mapper { return(0); }
                """.stripMargin)
    assert(messages.length === 6, "expecting six errors")
    assertTypeErrorWithInferredType(messages, 0, 9, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 1, 10, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 2, 11, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 3, 12, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 4, 13, 9, "boolean")
    assertTypeErrorWithInferredType(messages, 5, 14, 9, "boolean")
  }
}
